{
    /*************************************** #defines *******************************************/
    "vector<int>": {
        "prefix": "vi",
        "body": [
            "vector <int> "
        ],
        "description": "vector<int>"
    },
    "vector<bool>": {
        "prefix": "vb",
        "body": [
            "vector <bool> "
        ],
        "description": "vector<bool>"
    },
    "vector<string>": {
        "prefix": "vs",
        "body": [
            "vector <string> "
        ],
        "description": "vector<string>"
    },
    "vector<vector<int>>": {
        "prefix": "vvi",
        "body": [
            "vector< vector<int> > "
        ],
        "description": "vector<vector<int>>"
    },
    "vector<vector<bool>>": {
        "prefix": "vvb",
        "body": [
            "vector< vector<bool> > "
        ],
        "description": "vector<vector<bool>>"
    },
    "vector<vector<string>>": {
        "prefix": "vvs",
        "body": [
            "vector< vector<string> > "
        ],
        "description": "vector<vector<string>>"
    },
    "pair<int,int>": {
        "prefix": "pii",
        "body": [
            "pair <int,int> "
        ],
        "description": "pair<int,int>"
    },
    "vector<pair<int,int>>": {
        "prefix": "vpii",
        "body": [
            "vector<pair<int,int> > "
        ],
        "description": "vector<pair<int,int>>"
    },
    "Trace": {
        "prefix": "trace",
        "body": [
            "for (auto it = ${1:s}.begin(); it != ${1:s}.end(); it++)",
            "{",
            "    $0",
            "}"
        ],
        "description": "Trace"
    },
    "cout<<\"YES\\n\"": {
        "prefix": "pfy",
        "body": [
            "cout<<\"YES\\n\";"
        ],
        "description": "cout<<\"YES\\n\""
    },
    "cout<<\"NO\\n\"": {
        "prefix": "pfn",
        "body": [
            "cout<<\"NO\\n\";"
        ],
        "description": "cout<<\"NO\\n\""
    },
    "cout<<\"\\n\"": {
        "prefix": "nl",
        "body": [
            "cout<<\"\\n\";"
        ],
        "description": "cout<<\"\\n\""
    },
    "cout<<\"-1\\n\"": {
        "prefix": "pfn1",
        "body": [
            "cout<<\"-1\\n\";"
        ],
        "description": "cout<<\"-1\\n\""
    },
    "popcount": {
        "prefix": "popcount",
        "body": [
            "__builtin_popcountll($0)"
        ],
        "description": "popcount"
    },
    "2-D Array Helper": {
        "prefix": "lib-helper-2d-array",
        "body": [
            "vector<int> plus_x={0,1,0,-1};",
            "vector<int> plus_y={-1,0,1,0};",
            "",
            "vector<int> star_x={1,1,-1,-1};",
            "vector<int> star_y={-1,1,1,-1};",
            "",
            "vector<int> square_x={0,1,1,1,0,-1,-1,-1};",
            "vector<int> square_y={-1,-1,0,1,1,1,0,-1};",
            "",
            "bool is_inside(int x,int y,int n,int m)",
            "{",
            "    return (x>=0 && x<n && y>=0 && y<m);",
            "}"
        ],
        "description": "2-D Array Helper Vectors"
    },
    "Debug": {
        "prefix": "lib-debug",
        "body": [
            "template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }",
            "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }",
            "void dbg_out() { cerr << endl; }",
            "template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }",
            "#ifndef ONLINE_JUDGE",
            "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
            "#else",
            "#define dbg(...)",
            "#endif"
        ],
        "description": "Debug"
    },
    /*************************************** Library Functions *******************************************/
    "Inversions from Merge Sort": {
        "prefix": "lib-inversions-merge-sort",
        "body": [
            "int merge(vector <int> &a,int left,int mid,int right)",
            "{",
            "    int i=left;",
            "    int j=mid+1;",
            "    int k=0;",
            "    int inversions=0;",
            "    vector <int> temp(right-left+1);",
            "",
            "    while (i<=mid && j<=right){",
            "        if(a[i]<=a[j]) temp[k++]=a[i++];",
            "        else temp[k++]=a[j++],inversions+=mid-i+1;",
            "    }",
            "",
            "    while (i<=mid) temp[k++]=a[i++];",
            "    while (j<=right) temp[k++]=a[j++];",
            "    for(int i=left;i<=right;i++) a[i]=temp[i-left];",
            "    ",
            "    return inversions;",
            "}",
            "",
            "int merge_sort(vector <int> &a,int left,int right)",
            "{",
            "    if(left>=right)return 0;",
            "",
            "    int mid=(left+right)/2;",
            "    int inversions = 0;",
            "",
            "    inversions+=merge_sort(a,left,mid);",
            "    inversions+=merge_sort(a,mid+1,right);",
            "    inversions+=merge(a,left,mid,right);",
            "",
            "    return inversions;",
            "}",
            "/*",
            "    counting inversions from fenwick tree/segment tree :-",
            "        (a) by making indices as array values, will have to do co-ordinate shifting if some values are negative",
            "",
            "            time complexity : O(MAX*log(MAX))",
            "            auxiliary space complexity : BigTheta(MAX)",
            "",
            "        (b) by first sorting the array and make their values as permutation of n elements,",
            "            keeping the relative order of smaller and greater elements same",
            "",
            "            time complexity : O(nlogn)",
            "            auxiliary space complexity : O(n)",
            "",
            "        https://codeforces.com/edu/course/2/lesson/4/3",
            "        https://www.geeksforgeeks.org/count-inversions-array-set-3-using-bit/",
            "",
            "    counting inversions from merge sort :-",
            "        time complexity : O(nlogn)",
            "        auxiliary space complexity : O(n)",
            "        https://www.geeksforgeeks.org/counting-inversions/",
            "",
            "        // merge_sort$0(arr,0,n-1) will sort the vector in O(nlogn) and return the inversions in the old vector",
            "",
            "*/"
        ],
        "description": "Inversions from Merge Sort"
    },
    "Dijkstra on sparse graphs": {
        "prefix": "lib-dijkstra",
        "body": [
            "// O(nlogn+mlogn)",
            "// Dijkstra on sparse graphs",
            "void dijkstra(int s, vector<int> & d, vector<int> & p) {",
            "    int n = adj.size();",
            "    d.assign(n, INF);",
            "    p.assign(n, -1);",
            "",
            "    d[s] = 0;",
            "    using pii = pair<int, int>;",
            "    priority_queue<pii, vector<pii>, greater<pii>> q;",
            "    q.push({0, s});",
            "    while (!q.empty()) {",
            "        int v = q.top().second;",
            "        int d_v = q.top().first;",
            "        q.pop();",
            "        if (d_v != d[v])",
            "            continue;",
            "",
            "        for (auto edge : adj[v]) {",
            "            int to = edge.first;",
            "            int len = edge.second;",
            "",
            "            if (d[v] + len < d[to]) {",
            "                /*",
            "                    q.erase({d[to], to});",
            "",
            "                    no need to erase, let the old pair be in the priority_queue,",
            "                    since we are always accessing the smallest pair,",
            "                    this old pair will never be used.",
            "                */",
            "                d[to] = d[v] + len;",
            "                p[to] = v;",
            "                q.push({d[to], to});",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Dijkstra on sparse graphs"
    },
    "is-Bipartite": {
        "prefix": "lib-is-bipartite",
        "body": [
            "vector<int> side(n, -1);",
            "bool is_bipartite = true;",
            "queue<int> q;",
            "for (int st = 0; st < n; ++st) {",
            "    if (side[st] == -1) {",
            "        q.push(st);",
            "        side[st] = 0;",
            "        while (!q.empty()) {",
            "            int v = q.front();",
            "            q.pop();",
            "            for (int u : adj[v]) {",
            "                if (side[u] == -1) {",
            "                    side[u] = side[v] ^ 1;",
            "                    q.push(u);",
            "                } else {",
            "                    is_bipartite &= side[u] != side[v];",
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "is-Bipartite"
    },
    // "is_DAG-old": {
    //     "prefix": "lib-is-DAG-old",
    //     "body": [
    //         "enum Color { White, Grey, Black };",
    //         "vector<Color> color(mxn$0,White);",
    //         "",
    //         "// Returns true if the connected component of",
    //         "// node 'v' in the directed graph contains any cycle.",
    //         "bool contains_cycle(int v)",
    //         "{",
    //         "    color[v] = Grey;",
    //         "",
    //         "    for (int u : adj[v])",
    //         "    {",
    //         "        if (color[u] == White)",
    //         "        {",
    //         "            if (contains_cycle(u))return true;",
    //         "",
    //         "        } else if (color[u] == Grey)",
    //         "        {",
    //         "            return true;",
    //         "        }",
    //         "    }",
    //         "    color[v] = Black;",
    //         "    return false;",
    //         "}",
    //         "",
    //         "// returns true if the directed graph is a DAG(Directed Acyclic Graph) in O(N+M)",
    //         "bool is_DAG(int N)",
    //         "{",
    //         "    for (int v = 0; v < N; v++)",
    //         "    {",
    //         "        if (color[v] == White && contains_cycle(v))return false;",
    //         "    }",
    //         "",
    //         "    return true;",
    //         "}"
    //     ],
    //     "description": "check if drected graph is acyclic or not"
    // },
    "Topological Sort": {
        "prefix": "lib-topological-sort",
        "body": [
            "vector<int> color_DAG;",
            "int cycle_start=-1, cycle_end=-1;",
            "",
            "bool dfs_DAG(int v) {",
            "    color_DAG[v] = 1;",
            "    for (int u : adj[v]) {",
            "        if (color_DAG[u] == 0) {",
            "            if (dfs_DAG(u))",
            "                return true;",
            "        } else if (color_DAG[u] == 1) {",
            "            // found atleast one cycle which starts at node u and",
            "            // end at node v, so the given directed is cyclic",
            "            // Thus, NOT a DAG",
            "            cycle_end = v;",
            "            cycle_start = u;",
            "            return true;",
            "        }",
            "    }",
            "    color_DAG[v] = 2;",
            "    return false;",
            "}",
            "",
            "// returns true if the directed graph is a DAG(Directed Acyclic Graph) in O(N+M)",
            "// nodes are 0 indexed from 0 to no_of_nodes_DAG-1",
            "bool is_DAG(int no_of_nodes_DAG) {",
            "",
            "    color_DAG.assign(no_of_nodes_DAG,0);",
            "    for (int v = 0; v < no_of_nodes_DAG; v++)",
            "        if (color_DAG[v] == 0 && dfs_DAG(v))break;",
            "",
            "    return cycle_start==-1;",
            "}",
            "",
            "vector<bool> visited_topo;",
            "vector<int> topo_sorted;",
            "",
            "void dfs_topo(int v) {",
            "    visited_topo[v] = true;",
            "    for (int u : adj[v]) {",
            "        if (!visited_topo[u])",
            "            dfs_topo(u);",
            "    }",
            "    topo_sorted.push_back(v);",
            "}",
            "",
            "// returns true if the directed graph has a topological sorting in O(N+M)",
            "// nodes are 0 indexed from 0 to no_of_nodes_topo-1",
            "bool topological_sort(int no_of_nodes_topo) {",
            "",
            "    if(!is_DAG(no_of_nodes_topo))",
            "    {",
            "        // Topological Sorting Only exists for Directed Acyclic Graphs.",
            "        return false;",
            "    }",
            "",
            "    visited_topo.assign(no_of_nodes_topo,false);",
            "    topo_sorted.clear();",
            "    for (int i = 0; i < no_of_nodes_topo; ++i) {",
            "        if (!visited_topo[i])",
            "            dfs_topo(i);",
            "    }",
            "",
            "    // topo_sorted is the topological sorting",
            "    reverse(topo_sorted.begin(), topo_sorted.end());",
            "    return true;",
            "}"
        ],
        "description": "Topological Sort"
    },
    "BinPow": {
        "prefix": "lib-binpow",
        "body": [
            "/*",
            "    modInverse(a) $0= binpow(a, phi(n)-1, n)",
            "    If n is prime, phi(n) = n-1",
            "    phi(n) = number of no.s from 1 to n co-prime with n",
            "*/",
            "int binpow(int a, int b=M-2, int m=M)",
            "{",
            "    assert(a>=0 && b>=0);",
            "    a%=m;",
            "    int res=1;",
            "    while (b)",
            "    {",
            "        if(b%2)res=res*a%m;",
            "        a=a*a%m;",
            "        b/=2;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "BinPow"
    },
    "ϕ(n) : Euler's Totient Function": {
        "prefix": "lib-phi",
        "body": [
            "/*",
            "    Euler's Totient Function",
            "    // O(√n)",
            "    // ϕ(n) = n*(1−1/p1)*(1−1/p2)...(1−1/pk)",
            "    // modInverse(a) = binpow(a, phi(n)-1, n)",
            "    // If n is prime, phi(n)=n-1",
            "*/",
            "int phi(int n) {",
            "    int result = n;",
            "    for (int i = 2; i * i <= n; i++) {",
            "        if (n % i == 0) {",
            "            while (n % i == 0)",
            "                n /= i;",
            "            result -= result / i;",
            "        }",
            "    }",
            "    if (n > 1)",
            "        result -= result / n;",
            "    return result;",
            "}"
        ],
        "description": "Euler's Totient Function"
    },
    "Euler totient function from 1 to n in O(nloglogn)": {
        "prefix": "lib-phi-1-to-n",
        "body": [
            "void phi_1_to_n(int n) {",
            "    vector<int> phi(n + 1);",
            "    phi[0] = 0;",
            "    phi[1] = 1;",
            "    for (int i = 2; i <= n; i++)",
            "        phi[i] = i;",
            "",
            "    for (int i = 2; i <= n; i++) {",
            "        if (phi[i] == i) {",
            "            for (int j = i; j <= n; j += i)",
            "                phi[j] -= phi[j] / i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Euler totient function from 1 to n in O(nloglogn)"
    },
    "nCr % M - Fermat Little Theorem": {
        "prefix": "lib-ncr",
        "body": [
            "// Fermat's Little Theorem in min(O(r),O(n-r))",
            "int ncr(int n, int r, int p = M) // nCr % p",
            "{",
            "    if (r > n - r)",
            "        r = n - r;",
            "",
            "    if (r == 0)",
            "        return 1;",
            "",
            "    int num2 = 1, num1 = 1, ans = 1;",
            "",
            "    for (int i = 1; i <= r; i++)",
            "    {",
            "        num1 *= (n + 1 - i) % p;",
            "        num1 %= p;",
            "        num2 *= i % p;",
            "        num2 %= p;",
            "    }",
            "",
            "    ans *= num1;",
            "    ans %= p;",
            "",
            "    // res will be binpow(num2,p-2,p)",
            "    // binpow algo starts....",
            "    int res = 1;",
            "    int x = num2, y = p - 2;",
            "    x = x % p;",
            "    while (y > 0)",
            "    {",
            "        if (y & 1)",
            "            res = (res * x) % p;",
            "        y = y >> 1;",
            "        x = (x * x) % p;",
            "    }",
            "    // binpow algo ends....",
            "",
            "    ans *= res;",
            "    ans %= p;",
            "    return ans;",
            "}"
        ],
        "description": "nCr % M - Fermat Little Theorem"
    },
    "Sieve of Eratosthenes": {
        "prefix": "lib-sieve",
        "body": [
            "#define ARYAN_SIEVE  ",
            "const int mxn_sieve = 1e5;",
            "",
            "int spf[mxn_sieve + 1]; // spf -> smallest prime factor",
            "// if spf[x]==x ,then x is prime",
            "void sieve()",
            "{",
            "    spf[1] = 1;",
            "    for (int i = 2; i <= mxn_sieve; i++)",
            "        spf[i] = i;",
            "",
            "    for (int i = 4; i <= mxn_sieve; i += 2)",
            "        spf[i] = 2;",
            "",
            "    for (int i = 3; i * i <= mxn_sieve; i++)",
            "    {",
            "        if (spf[i] == i)",
            "        {",
            "            for (int j = i * i; j <= mxn_sieve; j += i)",
            "                if (spf[j] == j)",
            "                    spf[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve of Eratosthenes"
    },
    "Segmented Sieve": {
        "prefix": "lib-seg-sieve",
        "body": [
            "#define ARYAN_SEG_SIEVE",
            "long long L=1;",
            "long long R=1e5;",
            "vector<bool> isPrime(R - L + 1, true);",
            "// For a no. 'X', use isPrime[X-L]",
            "void segmented_sieve() ",
            "{",
            "    long long lim = sqrt(R);",
            "    for (long long i = 2; i <= lim; ++i)",
            "        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)",
            "            isPrime[j - L] = false;",
            "    if (L == 1)",
            "        isPrime[0] = false;",
            "}"
        ],
        "description": "lib-segment-sieve"
    },
    "fact & inv. fact": {
        "prefix": "lib-fact",
        "body": [
            "#define ARYAN_FACT",
            "const int mxn_fact=1e5;",
            "int fact[mxn_fact+1];",
            "",
            "void fact_init()",
            "{",
            "    int MOD=M;",
            "    fact[0]=1;",
            "    for (int i=1;i<=mxn_fact;i++)",
            "        fact[i]=(i*fact[i-1])%MOD;",
            "}"
        ],
        "description": "Factorial Array"
    },
    "LIS - O(n^2) - array": {
        "prefix": "lib-lis-array",
        "body": [
            "// Longest Increasing Subsequence (LIS)",
            "// d[i] is length of LIS ending at 'i'",
            "// O(n^2) - DP",
            "vector<int> lis_array(vector<int> const& a) {",
            "    int n = a.size();",
            "    vector<int> d(n, 1);",
            "    for (int i = 0; i < n; i++) {",
            "        for (int j = 0; j < i; j++) {",
            "            if (a[j] < a[i])",
            "                d[i] = max(d[i], d[j] + 1);",
            "        }",
            "    }",
            "    return d;",
            "}"
        ],
        "description": "LIS - O(n^2) - Longest Increasing Subsequence - Returns an array"
    },
    "LIS - O(nlogn) - length": {
        "prefix": "lib-lis-length",
        "body": [
            "// Returns 'length' of Longest Increasing Subsequence (LIS)",
            "// d[i] is the element at which a subsequence of length 'i' terminates.",
            "// If there are multiple such sequences, then we take the one that ends in the smallest element",
            "// O(nlogn) - Binary Search",
            "// 'd' will be an non-decreasing array",
            "int lis_length(vector<int> const& a) {",
            "    int n = a.size();",
            "    const int INF = 1e9;",
            "    vector<int> d(n+1, INF);",
            "    d[0] = -INF;",
            "",
            "    for (int i = 0; i < n; i++) {",
            "        int j = upper_bound(d.begin(), d.end(), a[i]) - d.begin();",
            "        if (d[j-1] < a[i] && a[i] < d[j])",
            "            d[j] = a[i];",
            "    }",
            "",
            "    int ans = 0;",
            "    for (int i = 0; i <= n; i++) {",
            "        if (d[i] < INF)",
            "            ans = i;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "LIS - O(nlogn) - Longest Increasing Subsequence - Returns Length"
    },
    "BFS": {
        "prefix": "lib-bfs",
        "body": [
            "queue<int> q;",
            "vector<bool> visited(no_of_nodes);",
            "vector<int> distance(no_of_nodes), parent(no_of_nodes);",
            "",
            "q.push(source);",
            "visited[source] = true;",
            "parent[source] = -1;",
            "",
            "while (!q.empty()) {",
            "",
            "    int parent_node = q.front();",
            "    q.pop();",
            "",
            "    for (int child_node : adj[parent_node]) {",
            "",
            "        if (!visited[child_node])",
            "        {",
            "            visited[child_node] = true;",
            "            q.push(child_node);",
            "            distance[child_node] = distance[parent_node] + 1;",
            "            parent[child_node] = parent_node;",
            "        }",
            "    }",
            "}"
        ],
        "description": "BFS - (Min dist. from source) - (Breadth First Search)"
    },
    "LCS - Least Common Ancestor - O(logN)": {
        "prefix": "lib-lca",
        "body": [
            "// https://cp-algorithms.com/graph/lca_binary_lifting.html",
            "",
            "// GLOBAL VARIABLES...",
            "int n, l;",
            "vector<vector<int>> adj;",
            "",
            "int timer;",
            "vector<int> tin, tout;",
            "vector<vector<int>> up;",
            "",
            "void dfs(int v, int p)",
            "{",
            "    tin[v] = ++timer;",
            "    up[v][0] = p;",
            "    for (int i = 1; i <= l; ++i)",
            "        up[v][i] = up[up[v][i-1]][i-1];",
            "",
            "    for (int u : adj[v]) {",
            "        if (u != p)",
            "            dfs(u, v);",
            "    }",
            "",
            "    tout[v] = ++timer;",
            "}",
            "",
            "bool is_ancestor(int u, int v)",
            "{",
            "    return tin[u] <= tin[v] && tout[u] >= tout[v];",
            "}",
            "",
            "int lca(int u, int v)",
            "{",
            "    if (is_ancestor(u, v))",
            "        return u;",
            "    if (is_ancestor(v, u))",
            "        return v;",
            "    for (int i = l; i >= 0; --i) {",
            "        if (!is_ancestor(up[u][i], v))",
            "            u = up[u][i];",
            "    }",
            "    return up[u][0];",
            "}",
            "",
            "void preprocess(int root) {",
            "    tin.resize(n);",
            "    tout.resize(n);",
            "    timer = 0;",
            "    l = ceil(log2(n));",
            "    up.assign(n, vector<int>(l + 1));",
            "    dfs(root, root);",
            "}"
        ],
        "description": "LCS - Least Common Ancestor - O(logN) per query"
    },
    "Prefix Function/LPS Array": {
        "prefix": "lib-prefix-function-lps",
        "body": [
            "vector<int> prefix_function(string s) {",
            "    int n = (int)s.length();",
            "    vector<int> pi(n);",
            "    for (int i = 1; i < n; i++) {",
            "        int j = pi[i-1];",
            "        while (j > 0 && s[i] != s[j])",
            "            j = pi[j-1];",
            "        if (s[i] == s[j])",
            "            j++;",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}"
        ],
        "description": "Prefix Function/LPS Array"
    },
    "comparison-function": {
        "prefix": "lib-comp",
        "body": [
            "bool comp(pair <int,int>  a, pair <int,int>  b)",
            "{",
            "    return a.X < b.X;",
            "}"
        ],
        "description": "comparison-function (for sorting,lower_bound etc.)"
    },
    "GCD": {
        "prefix": "lib-gcd",
        "body": [
            "int gcd(int a, int b) /*__gcd doesn't work for big no.s*/",
            "{",
            "    if (b == 0)",
            "        return a;",
            "    return gcd(b, a % b);",
            "}"
        ],
        "description": "GCD"
    },
    "ceil() - for integers": {
        "prefix": "lib-ceil",
        "body": [
            "int ceil(int a, int b)",
            "{",
            "    return (a + b - 1) / b;",
            "}"
        ],
        "description": "Ceiling Function - For Integers"
    },
    /*************************************** DATA STRUCTURES *******************************************/
    "Trie": {
        "prefix": "lib-trie",
        "body": [
            "const int mxn_trie = 1e6 + 5;",
            "int child[mxn_trie][26];",
            "int no_of_ends[mxn_trie];",
            "int nxt = 1; // 0 is the root node",
            "",
            "void insert_trie(string const& s)",
            "{",
            "    int node=0;",
            "    for(char c : s)",
            "    {",
            "        if(child[node][c-'a']==0)",
            "        {",
            "            child[node][c-'a']=nxt++;",
            "        }",
            "        node=child[node][c-'a'];",
            "    }",
            "    no_of_ends[node]++;",
            "}",
            "",
            "bool search_trie(string const& key)",
            "{",
            "    int node=0;",
            "    for(char c : key)",
            "    {",
            "        if(child[node][c-'a']==0)",
            "        {",
            "            return false;",
            "        }",
            "        node=child[node][c-'a'];",
            "    }",
            "    ",
            "    return no_of_ends[node]>0;",
            "}"
        ],
        "description": "Trie"
    },
    "Segment Tree - Atcoder": {
        "prefix": "lib-seg-tree-atcoder",
        "body": [
            "/*",
            "    It is the data structure for monoids i.e., the algebraic structure that satisfies the following properties :",
            "        associativity: (a⋅b)⋅c = a⋅(b⋅c) for all a,b,c ∈ S",
            "        existence of the identity element: a⋅e = e⋅a = a for all a ∈ S",
            "",
            "    (1) segtree<S, binary_operation, identity_element> seg(int n)",
            "    (2) segtree<S, binary_operation, identity_element> seg(vector<S> v)",
            "        (1): It creates an array a of length n. All the elements are initialized to identity_element().",
            "        (2): It creates an array a of length n = v.size(), initialized to v.",
            "        0≤n≤10**8",
            "        O(n)",
            "",
            "    void seg.set(int p, S x)",
            "        It assigns x to a[p]",
            "        0≤p<n",
            "        O(logn)",
            "",
            "    S seg.get(int p)",
            "        It returns a[p]",
            "        0≤p<n",
            "        O(1)",
            "",
            "    S seg.prod(int l, int r)",
            "        It returns binary_operation(a[l], ..., a[r - 1]), assuming the properties of the monoid. It returns identity_element() if l=r.",
            "        0≤l≤r≤n",
            "        O(logn)",
            "",
            "    S seg.all_prod()",
            "        It returns op(a[0], ..., a[n - 1]), assuming the properties of the monoid. It returns identity_element() if n=0.",
            "        O(1)",
            "",
            "    (1) int seg.max_right<check_function>(int l)",
            "    (2) int seg.max_right<F>(int l, F check_function)",
            "        (1): It applies binary search on the segment tree. The function bool check_function(S x) should be defined.",
            "        (2): The function object that takes S as the argument and returns bool should be defined.",
            "",
            "        It returns an index r that satisfies both of the following :-",
            "            r = l or check_function(binary_operation(a[l], a[l + 1], ..., a[r - 1])) = true",
            "            r = n or check_function(binary_operation(a[l], a[l + 1], ..., a[r])) = false",
            "",
            "        If check_function is monotone, this is the maximum r that satisfies check_function(binary_operation(a[l], a[l+1], ..,a[r-1]))=true",
            "",
            "        if check_function is called with the same argument, it returns the same value, i.e., check_function has no side effect.",
            "        check_function(identity_element()) = true",
            "        0≤l≤n",
            "",
            "        O(logn)",
            "",
            "    (1) int seg.min_left<check_function>(int r)",
            "    (2) int seg.min_left<F>(int r, F check_function)",
            "        (1): It applies binary search on the segment tree. The function bool check_function(S x) should be defined.",
            "        (2): The function object that takes S as the argument and returns bool should be defined.",
            "",
            "        It returns an index l that satisfies both of the following :-",
            "            l = r or check_function(binary_operation(a[l], a[l + 1], ..., a[r - 1])) = true",
            "            l = 0 or check_function(binary_operation(a[l - 1], a[l], ..., a[r - 1])) = false",
            "",
            "        If check_function is monotone, this is the minimum l that satisfies check_function(binary_operation(a[l], a[l+1], ..,a[r-1]))=true",
            "",
            "        if check_function is called with the same argument, it returns the same value, i.e., check_function has no side effect.",
            "        check_function(identity_element()) = true",
            "        0≤r≤n",
            "",
            "        O(logn)",
            "",
            "    https://atcoder.github.io/ac-library/production/document_en/segtree.html",
            "",
            "*/",
            "",
            "template <class S, S (*op)(S, S), S (*e)()> struct segtree {",
            "  public:",
            "    segtree() : segtree(0) {}",
            "    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}",
            "    explicit segtree(const std::vector<S>& v) : _n((int)(v.size())) {",
            "        log = segtree::ceil_pow2(_n);",
            "        size = 1 << log;",
            "        d = std::vector<S>(2 * size, e());",
            "        for (int i = 0; i < _n; i++) d[size + i] = v[i];",
            "        for (int i = size - 1; i >= 1; i--) {",
            "            update(i);",
            "        }",
            "    }",
            "",
            "    void set(int p, S x) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        d[p] = x;",
            "        for (int i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "",
            "    S get(int p) const {",
            "        assert(0 <= p && p < _n);",
            "        return d[p + size];",
            "    }",
            "",
            "    S prod(int l, int r) const {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        S sml = e(), smr = e();",
            "        l += size;",
            "        r += size;",
            "",
            "        while (l < r) {",
            "            if (l & 1) sml = op(sml, d[l++]);",
            "            if (r & 1) smr = op(d[--r], smr);",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        return op(sml, smr);",
            "    }",
            "",
            "    S all_prod() const { return d[1]; }",
            "",
            "    template <bool (*f)(S)> int max_right(int l) const {",
            "        return max_right(l, [](S x) { return f(x); });",
            "    }",
            "    template <class F> int max_right(int l, F f) const {",
            "        assert(0 <= l && l <= _n);",
            "        assert(f(e()));",
            "        if (l == _n) return _n;",
            "        l += size;",
            "        S sm = e();",
            "        do {",
            "            while (l % 2 == 0) l >>= 1;",
            "            if (!f(op(sm, d[l]))) {",
            "                while (l < size) {",
            "                    l = (2 * l);",
            "                    if (f(op(sm, d[l]))) {",
            "                        sm = op(sm, d[l]);",
            "                        l++;",
            "                    }",
            "                }",
            "                return l - size;",
            "            }",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "        } while ((l & -l) != l);",
            "        return _n;",
            "    }",
            "",
            "    template <bool (*f)(S)> int min_left(int r) const {",
            "        return min_left(r, [](S x) { return f(x); });",
            "    }",
            "    template <class F> int min_left(int r, F f) const {",
            "        assert(0 <= r && r <= _n);",
            "        assert(f(e()));",
            "        if (r == 0) return 0;",
            "        r += size;",
            "        S sm = e();",
            "        do {",
            "            r--;",
            "            while (r > 1 && (r % 2)) r >>= 1;",
            "            if (!f(op(d[r], sm))) {",
            "                while (r < size) {",
            "                    r = (2 * r + 1);",
            "                    if (f(op(d[r], sm))) {",
            "                        sm = op(d[r], sm);",
            "                        r--;",
            "                    }",
            "                }",
            "                return r + 1 - size;",
            "            }",
            "            sm = op(d[r], sm);",
            "        } while ((r & -r) != r);",
            "        return 0;",
            "    }",
            "",
            "  private:",
            "    int _n, size, log;",
            "    std::vector<S> d;",
            "",
            "    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "",
            "    // @param n `0 <= n`",
            "    // @return minimum non-negative `x` s.t. `n <= 2**x`",
            "    int ceil_pow2(int n) {",
            "        int x = 0;",
            "        while ((1U << x) < (unsigned int)(n)) x++;",
            "        return x;",
            "    }",
            "",
            "};",
            "",
            "int binary_operation(int a,int b)",
            "{",
            "    return max(a,b);",
            "}",
            "",
            "int identity_element()",
            "{",
            "    return -INF;",
            "}",
            "",
            "int target;",
            "bool check_function(int v)",
            "{",
            "    return v<target;",
            "}",
            ""
        ],
        "description": "Segment Tree - Atcoder"
    },


    "segment tree": {
        "prefix": "lib-seg-tree-cpalgo",
        "body": [
            "struct segment{",
            "",
            "    // for getting range [L,R], PASS [L,R+1],",
            "",
            "    // any segment of l...r is [l,r)",
            "    // 'r' is not included in any segmented",
            "    // This segment tree is configured for min of a range, change according to your needs",
            "     ",
            "    int size;",
            "    vector <int>  arr;",
            " ",
            "    void init(int n){",
            "        size=1;",
            "        while(size<n)size*=2;",
            " ",
            "        arr.assign(2*size,0);",
            "    }",
            " ",
            "    // always pass 0 based index 'i'",
            "    // 'v' will be the final value of the element",
            "    void set(int i, int v,int x,int lx,int rx){",
            "        if(rx-lx==1){",
            "            arr[x]=v;",
            "            return;",
            "        }",
            " ",
            "        int mid=(lx+rx)/2;",
            " ",
            "        if(i<mid){",
            "            set(i,v,2*x+1,lx,mid);",
            "        }",
            "        else{",
            "            set(i,v,2*x+2,mid,rx);",
            "        }",
            " ",
            "        arr[x]=min(arr[2*x+1],arr[2*x+2]);",
            "    }",
            " ",
            "    void set(int i, int v){",
            "        set(i,v,0,0,size);",
            "    }",
            "",
            "    // always pass 0 based indexes of left & right [l,r)",
            "    // 'x' is the current index",
            "    // [lx,rx) is the current range",
            "    // [l,r) is the final range",
            "",
            "    int range(int l,int r,int x,int lx,int rx){",
            "        if(l>=rx || r<=lx)return INF;",
            "        if(lx>=l && rx<=r)return arr[x];",
            " ",
            "        int mid=(lx+rx)/2;",
            " ",
            "        int s1=range(l,r,2*x+1,lx,mid);",
            "        int s2=range(l,r,2*x+2,mid,rx);",
            " ",
            "        return min(s1,s2);",
            " ",
            "    }",
            " ",
            "    int range(int l,int r){",
            "        return range(l,r,0,0,size);",
            "    }",
            "",
            "    // https://codeforces.com/edu/course/2/lesson/4",
            "    // https://cp-algorithms.com/data_structures/segment_tree.html",
            " ",
            "};"
        ],
        "description": "Segment Tree - (Configured for finding min of range)"
    },

    "DSU": {
        "prefix": "lib-dsu",
        "body": [
            "/* ",
            "    dsu d(int n)",
            "    // It creates an undirected graph with n vertices and 0 edges.",
            "    // 0<=n<=1e8",
            "    // O(n)",
            "",
            "    int d.merge(int a, int b)",
            "    // It adds an edge (a, b)",
            "    // If the vertices a and b were in the same connected component, it returns the representative of this connected component. Otherwise, it returns the representative of the new connected component.",
            "    // 0<=a<n   0<=b<n",
            "    // O(alpha(n)) amortized",
            "",
            "    bool d.same(int a, int b)",
            "    // Returns whether the vertices a and b are in the same connected component",
            "    // 0<=a<n   0<=b<n",
            "    // O(alpha(n)) amortized",
            "",
            "    int d.leader(int a)",
            "    // Returns the representative of the connected component that contains the vertex a",
            "    // 0<=a<n",
            "    // O(alpha(n)) amortized",
            "",
            "    int d.size(int a)",
            "    // Returns the size of the connected component that contains the vertex a.",
            "    // 0<=a<n",
            "    // O(alpha(n)) amortized",
            "",
            "    vector<vector<int>> d.groups()",
            "    // Returns the list of the \"list of the vertices in a connected component\"",
            "    // O(n)",
            "*/",
            "struct dsu {",
            "  public:",
            "    dsu() : _n(0) {}",
            "    dsu(int n) : _n(n), parent_or_size(n, -1) {}",
            "",
            "    int merge(int a, int b) {",
            "        assert(0 <= a && a < _n);",
            "        assert(0 <= b && b < _n);",
            "        int x = leader(a), y = leader(b);",
            "        if (x == y) return x;",
            "        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);",
            "        parent_or_size[x] += parent_or_size[y];",
            "        parent_or_size[y] = x;",
            "        return x;",
            "    }",
            "",
            "    bool same(int a, int b) {",
            "        assert(0 <= a && a < _n);",
            "        assert(0 <= b && b < _n);",
            "        return leader(a) == leader(b);",
            "    }",
            "",
            "    int leader(int a) {",
            "        assert(0 <= a && a < _n);",
            "        if (parent_or_size[a] < 0) return a;",
            "        return parent_or_size[a] = leader(parent_or_size[a]);",
            "    }",
            "",
            "    int size(int a) {",
            "        assert(0 <= a && a < _n);",
            "        return -parent_or_size[leader(a)];",
            "    }",
            "",
            "    std::vector<std::vector<int>> groups() {",
            "        std::vector<int> leader_buf(_n), group_size(_n);",
            "        for (int i = 0; i < _n; i++) {",
            "            leader_buf[i] = leader(i);",
            "            group_size[leader_buf[i]]++;",
            "        }",
            "        std::vector<std::vector<int>> result(_n);",
            "        for (int i = 0; i < _n; i++) {",
            "            result[i].reserve(group_size[i]);",
            "        }",
            "        for (int i = 0; i < _n; i++) {",
            "            result[leader_buf[i]].push_back(i);",
            "        }",
            "        result.erase(",
            "            std::remove_if(result.begin(), result.end(),",
            "                           [&](const std::vector<int>& v) { return v.empty(); }),",
            "            result.end());",
            "        return result;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    // root node: -1 * component size",
            "    // otherwise: parent",
            "    std::vector<int> parent_or_size;",
            "};"
        ],
        "description": "DSU - Disjoint Set Union"
    },
    "Fenwick Tree": {
        "prefix": "lib-fenwick-tree",
        "body": [
            "/*",
            "    fenwick_tree<T> fw(int n)",
            "    // It creates an array a_0, a_1, ..., a_{n-1} of length n",
            "    // All the elements are initialized to 0",
            "    // T is int, uint, ll, ull, or modint",
            "    // 0<=n<=1e8",
            "    // O(n)",
            "",
            "    void fw.add(int p, T x)",
            "    // It processes a[p] += x",
            "    // 0<=p<n",
            "    // O(logn)",
            "",
            "    T fw.sum(int l, int r)",
            "    // It returns a[l] + a[l - 1] + ... + a[r - 1]",
            "    // 0<=l<=r<=n",
            "    // O(logn)",
            "*/",
            "template <class T> struct fenwick_tree {",
            "",
            "  public:",
            "    fenwick_tree() : _n(0) {}",
            "    fenwick_tree(int n) : _n(n), data(n) {}",
            "",
            "    void add(int p, T x) {",
            "        assert(0 <= p && p < _n);",
            "        p++;",
            "        while (p <= _n) {",
            "            data[p - 1] += (x);",
            "            p += p & -p;",
            "        }",
            "    }",
            "",
            "    T sum(int l, int r) {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        return sum(r) - sum(l);",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    std::vector<T> data;",
            "",
            "    T sum(int r) {",
            "        T s = 0;",
            "        while (r > 0) {",
            "            s += data[r - 1];",
            "            r -= r & -r;",
            "        }",
            "        return s;",
            "    }",
            "};"
        ],
        "description": "Fenwick Tree - BIT (Binary Indexed Tree)"
    },
    "Matrix": {
        "prefix": "lib-matrix",
        "body": [
            "template <typename T>",
            "class Matrix {",
            "public:",
            "",
            "\tvector < vector <T> > A;",
            "\tint r,c;",
            "",
            "\tMatrix(){",
            "\t\tthis->r = 0;",
            "\t\tthis->c = 0;",
            "\t}",
            "",
            "\t// make matrix of size 'r*c' initialized with 0",
            "\tMatrix(int r,int c){",
            "\t\tthis->r = r;",
            "\t\tthis->c = c;",
            "\t\tA.assign(r , vector <T> (c));",
            "\t}",
            "",
            "\t// make matrix of size 'r*c' initialized with 'val'",
            "\tMatrix(int r,int c,const T &val){",
            "\t\tthis->r = r;",
            "\t\tthis->c = c;",
            "\t\tA.assign(r , vector <T> (c , val));",
            "\t}",
            "",
            "\t// make identity matrix of size 'n*n'",
            "\tMatrix(int n){",
            "\t\tthis->r = this->c = n;",
            "\t\tA.assign(n , vector <T> (n));",
            "\t\tfor(int i=0;i<n;i++)",
            "\t\t\tA[i][i] = 1;",
            "\t}",
            "",
            "\t// unary plus",
            "\tMatrix operator+ () const{",
            "\t\tMatrix <T> C(r,c,0);",
            "\t\tfor(int i=0;i<r;i++)",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tC[i][j] = A[i][j];",
            "\t\treturn C;",
            "\t}",
            "\t// unary minus",
            "\tMatrix operator- () const{",
            "\t\tMatrix <T> C(r,c,0);",
            "\t\tfor(int i=0;i<r;i++)",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tC[i][j] = -A[i][j];",
            "\t\treturn C;",
            "\t}",
            "",
            "\tMatrix& operator += (const Matrix <T> &B){",
            "\t\tassert(r == B.r);",
            "\t\tassert(c == B.c);",
            "",
            "\t\tfor(int i=0;i<r;i++)",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tA[i][j] += B[i][j];",
            "",
            "\t\treturn *this;",
            "\t}",
            "\tMatrix& operator -= (const Matrix <T> &B){",
            "\t\tassert(r == B.r);",
            "\t\tassert(c == B.c);",
            "",
            "\t\tfor(int i=0;i<r;i++)",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tA[i][j] -= B[i][j];",
            "\t\t",
            "\t\treturn *this;",
            "\t}",
            "\tMatrix& operator *= (const Matrix <T> &B){",
            "\t\tassert(c == B.r);",
            "",
            "\t\tMatrix <T> C(r,B.c,0);",
            "\t\tfor(int i=0 ; i<r ; i++)",
            "\t\t\tfor(int j=0 ; j<B.c ; j++)",
            "\t\t\t\tfor(int k=0 ; k<c ; k++)",
            "\t\t\t\t\tC[i][j] += A[i][k] * B[k][j];",
            "",
            "\t\tthis->r = C.r;",
            "\t\tthis->c = C.c;",
            "\t\tthis->A = C.A;",
            "",
            "\t\treturn *this;",
            "\t}",
            "",
            "\t",
            "\tMatrix operator + (const Matrix <T> &B){",
            "\t\tassert(r == B.r);",
            "\t\tassert(c == B.c);",
            "",
            "\t\tMatrix <T> C(r,c,0);",
            "\t\tfor(int i=0;i<r;i++)",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tC[i][j] = A[i][j] + B[i][j];",
            "\t\treturn C;",
            "\t}",
            "\tMatrix operator - (const Matrix <T> &B){",
            "\t\tassert(r == B.r);",
            "\t\tassert(c == B.c);",
            "",
            "\t\tMatrix <T> C(r,c,0);",
            "\t\tfor(int i=0;i<r;i++)",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tC[i][j] = A[i][j] - B[i][j];",
            "",
            "\t\treturn C;",
            "\t}",
            "\tMatrix operator * (const Matrix <T> &B){",
            "\t\tassert(c == B.r);",
            "",
            "\t\tMatrix <T> C(r,B.c,0);",
            "\t\tfor(int i=0 ; i<r ; i++)",
            "\t\t\tfor(int j=0 ; j<B.c ; j++)",
            "\t\t\t\tfor(int k=0 ; k<c ; k++)",
            "\t\t\t\t\tC[i][j] += A[i][k] * B[k][j];",
            "",
            "\t\treturn C;",
            "\t}",
            "",
            "\tMatrix transpose(){",
            "\t\tMatrix <T> C(c,r);",
            "\t\tfor(int i=0;i<r;i++)",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tC[j][i] = A[i][j];",
            "",
            "\t\treturn C;",
            "\t}",
            "",
            "\tMatrix& transposeInplace(){",
            "\t\tMatrix <T> C(c,r);",
            "\t\tint i,j;",
            "\t\tfor(i=0;i<r;i++)",
            "\t\t\tfor(j=0;j<c;j++)",
            "\t\t\t\tC[j][i] = A[i][j];",
            "",
            "\t\tthis->r = C.r;",
            "\t\tthis->c = C.c;",
            "\t\tthis->A = C.A;",
            "",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tvector<T>& operator [] (int i){",
            "\t\tassert(i < r);",
            "\t\tassert(i >= 0);",
            "\t\treturn A[i];",
            "\t}",
            "",
            "\tconst vector<T>& operator [] (int i) const {",
            "\t\tassert(i < r);",
            "\t\tassert(i >= 0);",
            "\t\treturn A[i];",
            "\t}",
            "",
            "\tfriend ostream& operator << (ostream &out,const Matrix &M){",
            "\t\tfor (int i = 0; i < M.r; ++i) {",
            "\t\t\tfor (int j = 0; j < M.c; ++j)",
            "\t\t\t\tout << M[i][j]<< \" \";",
            "\t\t\tout << \"\\n\";",
            "\t\t}",
            "\t\treturn out;",
            "\t}",
            "\tvoid display(){",
            "\t\tfor(int i=0;i<r;i++){",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tcout << A[i][j]<< \" \";",
            "\t\t\tcout << \"\\n\";",
            "\t\t}",
            "\t}",
            "\t",
            "\t// Value of determinant of a square matrix in O(N^3)",
            "\tT determinant(){",
            "\t\tassert(r==c);",
            "",
            "\t\tT det = 1;",
            "\t\tfor(int i = 0; i < r; i++){",
            "\t\t\tif(A[i][i] == 0){",
            "\t\t\t\tfor(int j = i + 1; j < r; j++){",
            "\t\t\t\t\tif(A[j][i]==0)continue;",
            "\t\t\t\t\tfor(int k=0;k<r;k++)",
            "\t\t\t\t\t\tswap(A[i][k],A[j][k]);",
            "\t\t\t\t\tdet *= -1;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tif(A[i][i] == 0){",
            "\t\t\t\t\tdet=0;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "",
            "\t\t\tdet *= A[i][i];",
            "\t\t\tT number=A[i][i];",
            "\t\t\tfor(int k=0;k<r;k++)",
            "\t\t\t\tA[i][k] /= number;",
            "\t\t\t",
            "\t\t\tfor(int j = i + 1; j < r; j++){",
            "\t\t\t\tT number=A[j][i];",
            "\t\t\t\tfor(int k=i;k<r;k++)",
            "\t\t\t\t\tA[j][k] -= (A[i][k] * number);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\treturn det;",
            "\t}",
            "\t// binary exponentiation in O(logn)",
            "\tMatrix binpow (long long n) const{",
            "\t\tassert(n>=0);",
            "\t\tassert(r == c);",
            "",
            "\t\tMatrix <T> C(r);",
            "\t\tMatrix X(r,c,0);",
            "\t\tfor(int i=0;i<r;i++)",
            "\t\t\tfor(int j=0;j<c;j++)",
            "\t\t\t\tX[i][j] = A[i][j];",
            "",
            "\t\twhile(n){",
            "\t\t\tif(n&1)C*=X;",
            "\t\t\tX *= X;",
            "\t\t\tn /= 2;",
            "\t\t}",
            "\t\treturn C;",
            "\t}",
            "\t// https://github.com/mridul1809/CompetitiveProgramming/blob/master/templates/Matrix.cpp",
            "};",
            "// use mint$0 as T, for protecting overflow"
        ],
        "description": "Matrix"
    },
    "ordered_set": {
        "prefix": "lib-ordered-set",
        "body": [
            "// INCLUDE AT $0TOP (no #define int long long)",
            "// If you want to convert into ordered_multiset change less<int> to less_equal<int>",
            "// But then lower_bound will act as upper_bound",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set; ",
            "// order_of_key: The number of items in a set that are strictly smaller than k",
            "// find_by_order: It returns an iterator to the ith largest element"
        ],
        "description": "ordered_set"
    },
    "Random Integer": {
        "prefix": "lib-mt19937-random-integer",
        "body": [
            "mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());",
            "",
            "// random integer in [l,r]",
            "int getRand(int l, int r)",
            "{",
            "    /*",
            "        // you can also use this to get random permutation of indexes",
            "        vector<int> order(n);",
            "        iota(order.begin(), order.end(), 0);",
            "        shuffle(order.begin(), order.end(), rng);",
            "    */",
            "    uniform_int_distribution<int> uid(l, r);",
            "    return uid(rng);",
            "}"
        ],
        "description": "Random Integer mt19937"
    },
    /*************************************** MASTER TEMPLATES *******************************************/
    "1_1_Basic Template": {
        "prefix": "basic-lol",
        "body": [
            "/**",
            " *    author:  Aryan Agarwal",
            " *    created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND IST",
            "**/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define int long long",
            "",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    int _t = 1;",
            "    cin>>_t;",
            "    while(_t--)solve();",
            "    return 0;",
            "}"
        ],
        "description": "LOL Basic Template"
    },
    "1_2_Basic Template": {
        "prefix": "basic-log",
        "body": [
            "/**",
            " *    author:  Aryan Agarwal",
            " *    created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND IST",
            "**/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define int long long",
            "",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    int _t = 1;",
            "    // cin>>_t;",
            "    while(_t--)solve();",
            "    return 0;",
            "}"
        ],
        "description": "LOG Basic Template"
    },
    "lol": {
        "prefix": "lol",
        "body": [
            "/*",
            "\tauthor : aryan57",
            "\tcreated : $CURRENT_DATE-$CURRENT_MONTH_NAME-$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND IST",
            "*/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }",
            "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }",
            "void dbg_out() { cerr << endl; }",
            "template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }",
            "#ifndef ONLINE_JUDGE",
            "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
            "#else",
            "#define dbg(...)",
            "#endif",
            "",
            "#define int long long",
            "#define X first",
            "#define Y second",
            "#define pb push_back",
            "#define sz(a) ((int)(a).size())",
            "#define all(a) (a).begin(), (a).end()",
            "#define F(i, a, b) for (int i = a; i <= b; i++)",
            "#define RF(i, a, b) for (int i = a; i >= b; i--)",
            "",
            "const int mxn = 1e5;",
            "const long long INF = 2e18;",
            "const int32_t M = 1000000007;",
            "// const int32_t M = 998244353;",
            "const long double pie = acos(-1);",
            "",
            "void solve_LOL()",
            "{",
            "\t$0",
            "}",
            "",
            "signed main()",
            "{",
            "\tios_base::sync_with_stdio(false);",
            "\tcin.tie(nullptr);",
            "\tcout.tie(nullptr);",
            "#ifndef ONLINE_JUDGE",
            "// freopen(\"input.txt\",\"r\",stdin);",
            "// freopen(\"output.txt\",\"w\",stdout);",
            "#endif",
            "#ifdef ARYAN_SIEVE",
            "\tsieve();",
            "#endif",
            "#ifdef ARYAN_SEG_SIEVE",
            "\tsegmented_sieve();",
            "#endif",
            "#ifdef ARYAN_FACT",
            "\tfact_init();",
            "#endif",
            "\t// cout<<fixed<<setprecision(10);",
            "\tint _t=1;",
            "\tcin>>_t;",
            "\tfor (int i=1;i<=_t;i++)",
            "\t{",
            "\t\t// cout<<\"Case #\"<<i<<\": \";",
            "\t\tsolve_LOL();",
            "\t}",
            "\treturn 0;",
            "}"
        ],
        "description": "lol"
    },
    "log": {
        "prefix": "log",
        "body": [
            "/*",
            "\tauthor : aryan57",
            "\tcreated : $CURRENT_DATE-$CURRENT_MONTH_NAME-$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND IST",
            "*/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }",
            "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }",
            "void dbg_out() { cerr << endl; }",
            "template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }",
            "#ifndef ONLINE_JUDGE",
            "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
            "#else",
            "#define dbg(...)",
            "#endif",
            "",
            "#define int long long",
            "#define X first",
            "#define Y second",
            "#define pb push_back",
            "#define sz(a) ((int)(a).size())",
            "#define all(a) (a).begin(), (a).end()",
            "#define F(i, a, b) for (int i = a; i <= b; i++)",
            "#define RF(i, a, b) for (int i = a; i >= b; i--)",
            "",
            "const int mxn = 1e5;",
            "const long long INF = 2e18;",
            "const int32_t M = 1000000007;",
            "// const int32_t M = 998244353;",
            "const long double pie = acos(-1);",
            "",
            "void solve_LOG()",
            "{",
            "\t$0",
            "}",
            "",
            "signed main()",
            "{",
            "\tios_base::sync_with_stdio(false);",
            "\tcin.tie(nullptr);",
            "\tcout.tie(nullptr);",
            "#ifndef ONLINE_JUDGE",
            "// freopen(\"input.txt\",\"r\",stdin);",
            "// freopen(\"output.txt\",\"w\",stdout);",
            "#endif",
            "#ifdef ARYAN_SIEVE",
            "\tsieve();",
            "#endif",
            "#ifdef ARYAN_SEG_SIEVE",
            "\tsegmented_sieve();",
            "#endif",
            "#ifdef ARYAN_FACT",
            "\tfact_init();",
            "#endif",
            "\t// cout<<fixed<<setprecision(10);",
            "\tint _t=1;",
            "\t// cin>>_t;",
            "\tfor (int i=1;i<=_t;i++)",
            "\t{",
            "\t\t// cout<<\"Case #\"<<i<<\": \";",
            "\t\tsolve_LOG();",
            "\t}",
            "\treturn 0;",
            "}"
        ],
        "description": "log"
    },
    "google": {
        "prefix": "google",
        "body": [
            "/*",
            "\tauthor : aryan57",
            "\tcreated : $CURRENT_DATE-$CURRENT_MONTH_NAME-$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND IST",
            "*/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }",
            "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }",
            "void dbg_out() { cerr << endl; }",
            "template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }",
            "#ifndef ONLINE_JUDGE",
            "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
            "#else",
            "#define dbg(...)",
            "#endif",
            "",
            "#define int long long",
            "#define X first",
            "#define Y second",
            "#define pb push_back",
            "#define sz(a) ((int)(a).size())",
            "#define all(a) (a).begin(), (a).end()",
            "#define F(i, a, b) for (int i = a; i <= b; i++)",
            "#define RF(i, a, b) for (int i = a; i >= b; i--)",
            "",
            "const int mxn = 1e5;",
            "const long long INF = 2e18;",
            "const int32_t M = 1000000007;",
            "// const int32_t M = 998244353;",
            "const long double pie = acos(-1);",
            "",
            "void solve_GOOGLE()",
            "{",
            "\t$0",
            "}",
            "",
            "signed main()",
            "{",
            "\tios_base::sync_with_stdio(false);",
            "\tcin.tie(nullptr);",
            "\tcout.tie(nullptr);",
            "#ifndef ONLINE_JUDGE",
            "// freopen(\"input.txt\",\"r\",stdin);",
            "// freopen(\"output.txt\",\"w\",stdout);",
            "#endif",
            "#ifdef ARYAN_SIEVE",
            "\tsieve();",
            "#endif",
            "#ifdef ARYAN_SEG_SIEVE",
            "\tsegmented_sieve();",
            "#endif",
            "#ifdef ARYAN_FACT",
            "\tfact_init();",
            "#endif",
            "\t// cout<<fixed<<setprecision(10);",
            "\tint _t=1;",
            "\tcin>>_t;",
            "\tfor (int i=1;i<=_t;i++)",
            "\t{",
            "\t\tcout<<\"Case #\"<<i<<\": \";",
            "\t\tsolve_GOOGLE();",
            "\t}",
            "\treturn 0;",
            "}"
        ],
        "description": "google"
    },
    "Algorithms 1": {
        "prefix": "algo",
        "body": [
            "/*",
            "    author : Aryan Agarwal, 19CS30005",
            "    created : $CURRENT_DATE-$CURRENT_MONTH_NAME-$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND IST",
            "*/",
            "#include <iostream>",
            "using namespace std;",
            "",
            "int main()",
            "{",
            "",
            "    FILE *f1=nullptr;",
            "    FILE *f2=nullptr;",
            "",
            "    f1=fopen(\"in.txt\",\"r\");",
            "    f2=fopen(\"out.txt\",\"w\");",
            "    // fscanf(f1,\"%d %d\",&a,&b);",
            "    // fprintf(f2,\"%d:\",a);",
            "",
            "    if(f1==nullptr)cout<<\"-1\"<<endl;",
            "",
            "    $0",
            "",
            "",
            "    fclose(f1);",
            "    fclose(f2);",
            "    ",
            "    return 0;",
            "}"
        ],
        "description": "Algorithms 1"
    },

    "Chegg - Basic Template": {
        "prefix": "chegg",
        "body": [
            "#include <iostream>",
            "using namespace std;",
            "",
            "",
            "",
            "int main()",
            "{",
            "    $0",
            "    return 0;",
            "}"
        ],
        "description": "Basic Template"
    },
    /*************************************** MODULAR ARITHMETIC *******************************************/
    "modnum - ecnerwala": {
        "prefix": "lib-mint",
        "body": [
            "#include <cassert>",
            "#include <iostream>",
            "",
            "template <int MOD_> struct modnum {",
            "\tstatic constexpr int MOD = MOD_;",
            "\tstatic_assert(MOD_ > 0, \"MOD must be positive\");",
            "",
            "private:",
            "\tusing ll = long long;",
            "\tint v;",
            "\tstatic int minv(int a, int m) {",
            "\t\ta %= m;",
            "\t\tassert(a);",
            "\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);",
            "\t}",
            "",
            "public:",
            "",
            "\tmodnum() : v(0) {}",
            "\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }",
            "\texplicit operator int() const { return v; }",
            "\t",
            "    modnum binpow(long long b) const{",
            "        assert(b >= 0);",
            "        modnum a=this->v;",
            "        modnum r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;",
            "    }",
            "    ",
            "\tmodnum inv() const {",
            "\t\tmodnum res;",
            "\t\tres.v = minv(v, MOD);",
            "\t\treturn res;",
            "\t}",
            "",
            "\tmodnum operator- () const {modnum res;res.v = v ? MOD-v : 0;return res;}",
            "\tmodnum operator+ () const {return modnum(*this);}",
            "",
            "\tmodnum& operator ++ () {v ++;if (v == MOD) v = 0;return *this;}",
            "\tmodnum& operator -- () {if (v == 0) v = MOD;v --;return *this;}",
            "",
            "\tmodnum& operator += (const modnum& o) {v -= MOD-o.v;v = (v < 0) ? v + MOD : v;return *this;}",
            "\tmodnum& operator -= (const modnum& o) {v -= o.v;v = (v < 0) ? v + MOD : v;return *this;}",
            "\tmodnum& operator *= (const modnum& o) {v = int(ll(v) * ll(o.v) % MOD);return *this;}",
            "\tmodnum& operator /= (const modnum& o) {return *this *= o.inv();}",
            "",
            "",
            "\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }",
            "\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }",
            "\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }",
            "\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }",
            "\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }",
            "\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }",
            "",
            "\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }",
            "\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }",
            "",
            "\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }",
            "\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }",
            "",
            "\t// https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp",
            "};",
            "/*",
            "\t**if mod is preknown**",
            "\t\tusing mint = modnum<1000000007>;",
            "\t\tmint x=4;",
            "\t\tvector<mint> v;",
            "",
            "\t**dynamic mod used in functions**",
            "\t\tmodnum<23> x = 4;",
            "\t\tvector<modnum<100>> v;",
            "\t\tvector<modnum<1000000007>> v;",
            "",
            "\t**PASTE THIS SNIPPET AT TOP$0 MOST OF YOUR CODE**",
            "*/"
        ],
        "description": "Modular Arithmetic - Ecnerwala"
    },
    "Modular Arithmetic - Atcoder": {
        "prefix": "lib-mint-atcoder",
        "body": [
            "/***********",
            "WRITE THIS AT THE TOPMOST OF YOUR CODE",
            "***********/",
            "#include <utility>",
            "#include <cassert>",
            "#include <numeric>",
            "#include <type_traits>",
            "",
            "namespace atcoder {",
            "",
            "namespace internal {",
            "",
            "// @param m `1 <= m`",
            "// @return x mod m",
            "constexpr long long safe_mod(long long x, long long m) {",
            "    x %= m;",
            "    if (x < 0) x += m;",
            "    return x;",
            "}",
            "",
            "// Fast modular multiplication by barrett reduction",
            "// Reference: https://en.wikipedia.org/wiki/Barrett_reduction",
            "// NOTE: reconsider after Ice Lake",
            "struct barrett {",
            "    unsigned int _m;",
            "    unsigned long long im;",
            "",
            "    // @param m `1 <= m < 2^31`",
            "    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "",
            "    // @return m",
            "    unsigned int umod() const { return _m; }",
            "",
            "    // @param a `0 <= a < m`",
            "    // @param b `0 <= b < m`",
            "    // @return `a * b % m`",
            "    unsigned int mul(unsigned int a, unsigned int b) const {",
            "        // [1] m = 1",
            "        // a = b = im = 0, so okay",
            "",
            "        // [2] m >= 2",
            "        // im = ceil(2^64 / m)",
            "        // -> im * m = 2^64 + r (0 <= r < m)",
            "        // let z = a*b = c*m + d (0 <= c, d < m)",
            "        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im",
            "        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2",
            "        // ((ab * im) >> 64) == c or c + 1",
            "        unsigned long long z = a;",
            "        z *= b;",
            "",
            "        unsigned long long x =",
            "            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "",
            "        unsigned int v = (unsigned int)(z - x * _m);",
            "        if (_m <= v) v += _m;",
            "        return v;",
            "    }",
            "};",
            "",
            "// @param n `0 <= n`",
            "// @param m `1 <= m`",
            "// @return `(x ** n) % m`",
            "constexpr long long pow_mod_constexpr(long long x, long long n, int m) {",
            "    if (m == 1) return 0;",
            "    unsigned int _m = (unsigned int)(m);",
            "    unsigned long long r = 1;",
            "    unsigned long long y = safe_mod(x, m);",
            "    while (n) {",
            "        if (n & 1) r = (r * y) % _m;",
            "        y = (y * y) % _m;",
            "        n >>= 1;",
            "    }",
            "    return r;",
            "}",
            "",
            "// Reference:",
            "// M. Forisek and J. Jancina,",
            "// Fast Primality Testing for Integers That Fit into a Machine Word",
            "// @param n `0 <= n`",
            "constexpr bool is_prime_constexpr(int n) {",
            "    if (n <= 1) return false;",
            "    if (n == 2 || n == 7 || n == 61) return true;",
            "    if (n % 2 == 0) return false;",
            "    long long d = n - 1;",
            "    while (d % 2 == 0) d /= 2;",
            "    constexpr long long bases[3] = {2, 7, 61};",
            "    for (long long a : bases) {",
            "        long long t = d;",
            "        long long y = pow_mod_constexpr(a, t, n);",
            "        while (t != n - 1 && y != 1 && y != n - 1) {",
            "            y = y * y % n;",
            "            t <<= 1;",
            "        }",
            "        if (y != n - 1 && t % 2 == 0) {",
            "            return false;",
            "        }",
            "    }",
            "    return true;",
            "}",
            "template <int n> constexpr bool is_prime = is_prime_constexpr(n);",
            "",
            "// @param b `1 <= b`",
            "// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g",
            "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "    a = safe_mod(a, b);",
            "    if (a == 0) return {b, 0};",
            "",
            "    // Contracts:",
            "    // [1] s - m0 * a = 0 (mod b)",
            "    // [2] t - m1 * a = 0 (mod b)",
            "    // [3] s * |m1| + t * |m0| <= b",
            "    long long s = b, t = a;",
            "    long long m0 = 0, m1 = 1;",
            "",
            "    while (t) {",
            "        long long u = s / t;",
            "        s -= t * u;",
            "        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b",
            "",
            "        // [3]:",
            "        // (s - t * u) * |m1| + t * |m0 - m1 * u|",
            "        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)",
            "        // = s * |m1| + t * |m0| <= b",
            "",
            "        auto tmp = s;",
            "        s = t;",
            "        t = tmp;",
            "        tmp = m0;",
            "        m0 = m1;",
            "        m1 = tmp;",
            "    }",
            "    // by [3]: |m0| <= b/g",
            "    // by g != b: |m0| < b/g",
            "    if (m0 < 0) m0 += b / s;",
            "    return {s, m0};",
            "}",
            "",
            "// Compile time primitive root",
            "// @param m must be prime",
            "// @return primitive root (and minimum in now)",
            "constexpr int primitive_root_constexpr(int m) {",
            "    if (m == 2) return 1;",
            "    if (m == 167772161) return 3;",
            "    if (m == 469762049) return 3;",
            "    if (m == 754974721) return 11;",
            "    if (m == 998244353) return 3;",
            "    int divs[20] = {};",
            "    divs[0] = 2;",
            "    int cnt = 1;",
            "    int x = (m - 1) / 2;",
            "    while (x % 2 == 0) x /= 2;",
            "    for (int i = 3; (long long)(i)*i <= x; i += 2) {",
            "        if (x % i == 0) {",
            "            divs[cnt++] = i;",
            "            while (x % i == 0) {",
            "                x /= i;",
            "            }",
            "        }",
            "    }",
            "    if (x > 1) {",
            "        divs[cnt++] = x;",
            "    }",
            "    for (int g = 2;; g++) {",
            "        bool ok = true;",
            "        for (int i = 0; i < cnt; i++) {",
            "            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {",
            "                ok = false;",
            "                break;",
            "            }",
            "        }",
            "        if (ok) return g;",
            "    }",
            "}",
            "template <int m> constexpr int primitive_root = primitive_root_constexpr(m);",
            "",
            "}  // namespace internal",
            "",
            "}  // namespace atcoder",
            "",
            "namespace atcoder {",
            "",
            "namespace internal {",
            "",
            "template <class T>",
            "using is_signed_int128 =",
            "    typename std::conditional<std::is_same<T, __int128_t>::value ||",
            "                                  std::is_same<T, __int128>::value,",
            "                              std::true_type,",
            "                              std::false_type>::type;",
            "",
            "template <class T>",
            "using is_unsigned_int128 =",
            "    typename std::conditional<std::is_same<T, __uint128_t>::value ||",
            "                                  std::is_same<T, unsigned __int128>::value,",
            "                              std::true_type,",
            "                              std::false_type>::type;",
            "",
            "template <class T>",
            "using make_unsigned_int128 =",
            "    typename std::conditional<std::is_same<T, __int128_t>::value,",
            "                              __uint128_t,",
            "                              unsigned __int128>;",
            "",
            "template <class T>",
            "using is_integral = typename std::conditional<std::is_integral<T>::value ||",
            "                                                  is_signed_int128<T>::value ||",
            "                                                  is_unsigned_int128<T>::value,",
            "                                              std::true_type,",
            "                                              std::false_type>::type;",
            "",
            "template <class T>",
            "using is_signed_int = typename std::conditional<(is_integral<T>::value &&",
            "                                                 std::is_signed<T>::value) ||",
            "                                                    is_signed_int128<T>::value,",
            "                                                std::true_type,",
            "                                                std::false_type>::type;",
            "",
            "template <class T>",
            "using is_unsigned_int =",
            "    typename std::conditional<(is_integral<T>::value &&",
            "                               std::is_unsigned<T>::value) ||",
            "                                  is_unsigned_int128<T>::value,",
            "                              std::true_type,",
            "                              std::false_type>::type;",
            "",
            "template <class T>",
            "using to_unsigned = typename std::conditional<",
            "    is_signed_int128<T>::value,",
            "    make_unsigned_int128<T>,",
            "    typename std::conditional<std::is_signed<T>::value,",
            "                              std::make_unsigned<T>,",
            "                              std::common_type<T>>::type>::type;",
            "",
            "",
            "template <class T>",
            "using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "template <class T>",
            "using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "template <class T> using to_unsigned_t = typename to_unsigned<T>::type;",
            "",
            "}  // namespace internal",
            "",
            "}  // namespace atcoder",
            "",
            "namespace atcoder {",
            "",
            "namespace internal {",
            "",
            "struct modint_base {};",
            "struct static_modint_base : modint_base {};",
            "",
            "template <class T> using is_modint = std::is_base_of<modint_base, T>;",
            "template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "",
            "}  // namespace internal",
            "",
            "template <int m, std::enable_if_t<(1 <= m)>* = nullptr>",
            "struct static_modint : internal::static_modint_base {",
            "    using mint = static_modint;",
            "",
            "  public:",
            "    static constexpr int mod() { return m; }",
            "    static mint raw(int v) {",
            "        mint x;",
            "        x._v = v;",
            "        return x;",
            "    }",
            "",
            "    static_modint() : _v(0) {}",
            "    template <class T, internal::is_signed_int_t<T>* = nullptr>",
            "    static_modint(T v) {",
            "        long long x = (long long)(v % (long long)(umod()));",
            "        if (x < 0) x += umod();",
            "        _v = (unsigned int)(x);",
            "    }",
            "    template <class T, internal::is_unsigned_int_t<T>* = nullptr>",
            "    static_modint(T v) {",
            "        _v = (unsigned int)(v % umod());",
            "    }",
            "    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }",
            "",
            "    unsigned int val() const { return _v; }",
            "",
            "    mint& operator++() {",
            "        _v++;",
            "        if (_v == umod()) _v = 0;",
            "        return *this;",
            "    }",
            "    mint& operator--() {",
            "        if (_v == 0) _v = umod();",
            "        _v--;",
            "        return *this;",
            "    }",
            "    mint operator++(int) {",
            "        mint result = *this;",
            "        ++*this;",
            "        return result;",
            "    }",
            "    mint operator--(int) {",
            "        mint result = *this;",
            "        --*this;",
            "        return result;",
            "    }",
            "",
            "    mint& operator+=(const mint& rhs) {",
            "        _v += rhs._v;",
            "        if (_v >= umod()) _v -= umod();",
            "        return *this;",
            "    }",
            "    mint& operator-=(const mint& rhs) {",
            "        _v -= rhs._v;",
            "        if (_v >= umod()) _v += umod();",
            "        return *this;",
            "    }",
            "    mint& operator*=(const mint& rhs) {",
            "        unsigned long long z = _v;",
            "        z *= rhs._v;",
            "        _v = (unsigned int)(z % umod());",
            "        return *this;",
            "    }",
            "    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }",
            "",
            "    mint operator+() const { return *this; }",
            "    mint operator-() const { return mint() - *this; }",
            "",
            "    mint pow(long long n) const {",
            "        assert(0 <= n);",
            "        mint x = *this, r = 1;",
            "        while (n) {",
            "            if (n & 1) r *= x;",
            "            x *= x;",
            "            n >>= 1;",
            "        }",
            "        return r;",
            "    }",
            "    mint inv() const {",
            "        if (prime) {",
            "            assert(_v);",
            "            return pow(umod() - 2);",
            "        } else {",
            "            auto eg = internal::inv_gcd(_v, m);",
            "            assert(eg.first == 1);",
            "            return eg.second;",
            "        }",
            "    }",
            "",
            "    friend mint operator+(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) += rhs;",
            "    }",
            "    friend mint operator-(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) -= rhs;",
            "    }",
            "    friend mint operator*(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) *= rhs;",
            "    }",
            "    friend mint operator/(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) /= rhs;",
            "    }",
            "    friend bool operator==(const mint& lhs, const mint& rhs) {",
            "        return lhs._v == rhs._v;",
            "    }",
            "    friend bool operator!=(const mint& lhs, const mint& rhs) {",
            "        return lhs._v != rhs._v;",
            "    }",
            "",
            "  private:",
            "    unsigned int _v;",
            "    static constexpr unsigned int umod() { return m; }",
            "    static constexpr bool prime = internal::is_prime<m>;",
            "};",
            "",
            "template <int id> struct dynamic_modint : internal::modint_base {",
            "    using mint = dynamic_modint;",
            "",
            "  public:",
            "    static int mod() { return (int)(bt.umod()); }",
            "    static void set_mod(int m) {",
            "        assert(1 <= m);",
            "        bt = internal::barrett(m);",
            "    }",
            "    static mint raw(int v) {",
            "        mint x;",
            "        x._v = v;",
            "        return x;",
            "    }",
            "",
            "    dynamic_modint() : _v(0) {}",
            "    template <class T, internal::is_signed_int_t<T>* = nullptr>",
            "    dynamic_modint(T v) {",
            "        long long x = (long long)(v % (long long)(mod()));",
            "        if (x < 0) x += mod();",
            "        _v = (unsigned int)(x);",
            "    }",
            "    template <class T, internal::is_unsigned_int_t<T>* = nullptr>",
            "    dynamic_modint(T v) {",
            "        _v = (unsigned int)(v % mod());",
            "    }",
            "    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }",
            "",
            "    unsigned int val() const { return _v; }",
            "",
            "    mint& operator++() {",
            "        _v++;",
            "        if (_v == umod()) _v = 0;",
            "        return *this;",
            "    }",
            "    mint& operator--() {",
            "        if (_v == 0) _v = umod();",
            "        _v--;",
            "        return *this;",
            "    }",
            "    mint operator++(int) {",
            "        mint result = *this;",
            "        ++*this;",
            "        return result;",
            "    }",
            "    mint operator--(int) {",
            "        mint result = *this;",
            "        --*this;",
            "        return result;",
            "    }",
            "",
            "    mint& operator+=(const mint& rhs) {",
            "        _v += rhs._v;",
            "        if (_v >= umod()) _v -= umod();",
            "        return *this;",
            "    }",
            "    mint& operator-=(const mint& rhs) {",
            "        _v += mod() - rhs._v;",
            "        if (_v >= umod()) _v -= umod();",
            "        return *this;",
            "    }",
            "    mint& operator*=(const mint& rhs) {",
            "        _v = bt.mul(_v, rhs._v);",
            "        return *this;",
            "    }",
            "    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }",
            "",
            "    mint operator+() const { return *this; }",
            "    mint operator-() const { return mint() - *this; }",
            "",
            "    mint pow(long long n) const {",
            "        assert(0 <= n);",
            "        mint x = *this, r = 1;",
            "        while (n) {",
            "            if (n & 1) r *= x;",
            "            x *= x;",
            "            n >>= 1;",
            "        }",
            "        return r;",
            "    }",
            "    mint inv() const {",
            "        auto eg = internal::inv_gcd(_v, mod());",
            "        assert(eg.first == 1);",
            "        return eg.second;",
            "    }",
            "",
            "    friend mint operator+(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) += rhs;",
            "    }",
            "    friend mint operator-(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) -= rhs;",
            "    }",
            "    friend mint operator*(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) *= rhs;",
            "    }",
            "    friend mint operator/(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) /= rhs;",
            "    }",
            "    friend bool operator==(const mint& lhs, const mint& rhs) {",
            "        return lhs._v == rhs._v;",
            "    }",
            "    friend bool operator!=(const mint& lhs, const mint& rhs) {",
            "        return lhs._v != rhs._v;",
            "    }",
            "",
            "  private:",
            "    unsigned int _v;",
            "    static internal::barrett bt;",
            "    static unsigned int umod() { return bt.umod(); }",
            "};",
            "template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;",
            "",
            "using modint998244353 = static_modint<998244353>;",
            "using modint1000000007 = static_modint<1000000007>;",
            "using modint = dynamic_modint<-1>;",
            "",
            "namespace internal {",
            "",
            "template <class T>",
            "using is_static_modint = std::is_base_of<internal::static_modint_base, T>;",
            "",
            "template <class T>",
            "using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;",
            "",
            "template <class> struct is_dynamic_modint : public std::false_type {};",
            "template <int id>",
            "struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};",
            "",
            "template <class T>",
            "using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;",
            "",
            "}  // namespace internal",
            "",
            "}  // namespace atcoder",
            "",
            "/*",
            "    Constructor",
            "    // (1) modint x()",
            "    // It is the default constructor of modint. 0 will be stored.",
            "    // (2) modint x<T>(T y)",
            "    // It is the constructor for the integer type T(int, char, ull, bool, ...). y is stored in modint after taking mod.",
            "",
            "    set_mod",
            "    // void modint::set_mod(int m)",
            "    // It sets the mod. It must be called first.",
            "    // 1 <= m <= 2e9+1000",
            "    // O(1)",
            "",
            "    mod",
            "    // int modint::mod()",
            "    // It returns the mod.",
            "",
            "    val",
            "    // int x.val();",
            "    // It returns the value that is stored in x.",
            "",
            "    pow",
            "    // modint x.pow(ll n)",
            "    // It returns x^(n)",
            "    // 0<=n",
            "    // O(logn)",
            "",
            "    inv",
            "    // modint x.inv()",
            "    // It returns y with xy ≡ 1",
            "    // gcd(x.val(), mod) = 1",
            "    // O(logmod)",
            "",
            "    raw",
            "    // modint modint::raw(int x)",
            "    // It returns modint(x) without taking mod",
            "    // When the value more than or equal to mod is assigned to modint::raw(x), the behavior is undefined.",
            "    // 0<=x<mod",
            "",
            "*/",
            "using namespace atcoder;",
            "using mint = modint;   // write $0 mint::set_mod(SOME_NUMBER); in the solve() function",
            "// using mint = modint998244353;",
            "// using mint = modint1000000007;",
        ],
        "description": "Modular Arithmetic"
    },
    "Modular Arithmetic - Atcoder - Complete": {
        "prefix": "lib-mint-atcoder-complete",
        "body": [
            "#ifndef ATCODER_MODINT_HPP",
            "#define ATCODER_MODINT_HPP 1",
            "",
            "#ifndef ATCODER_INTERNAL_MATH_HPP",
            "#define ATCODER_INTERNAL_MATH_HPP 1",
            "",
            "#include <utility>",
            "",
            "namespace atcoder {",
            "",
            "namespace internal {",
            "",
            "// @param m `1 <= m`",
            "// @return x mod m",
            "constexpr long long safe_mod(long long x, long long m) {",
            "    x %= m;",
            "    if (x < 0) x += m;",
            "    return x;",
            "}",
            "",
            "// Fast modular multiplication by barrett reduction",
            "// Reference: https://en.wikipedia.org/wiki/Barrett_reduction",
            "// NOTE: reconsider after Ice Lake",
            "struct barrett {",
            "    unsigned int _m;",
            "    unsigned long long im;",
            "",
            "    // @param m `1 <= m < 2^31`",
            "    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "",
            "    // @return m",
            "    unsigned int umod() const { return _m; }",
            "",
            "    // @param a `0 <= a < m`",
            "    // @param b `0 <= b < m`",
            "    // @return `a * b % m`",
            "    unsigned int mul(unsigned int a, unsigned int b) const {",
            "        // [1] m = 1",
            "        // a = b = im = 0, so okay",
            "",
            "        // [2] m >= 2",
            "        // im = ceil(2^64 / m)",
            "        // -> im * m = 2^64 + r (0 <= r < m)",
            "        // let z = a*b = c*m + d (0 <= c, d < m)",
            "        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im",
            "        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2",
            "        // ((ab * im) >> 64) == c or c + 1",
            "        unsigned long long z = a;",
            "        z *= b;",
            "#ifdef _MSC_VER",
            "        unsigned long long x;",
            "        _umul128(z, im, &x);",
            "#else",
            "        unsigned long long x =",
            "            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "#endif",
            "        unsigned int v = (unsigned int)(z - x * _m);",
            "        if (_m <= v) v += _m;",
            "        return v;",
            "    }",
            "};",
            "",
            "// @param n `0 <= n`",
            "// @param m `1 <= m`",
            "// @return `(x ** n) % m`",
            "constexpr long long pow_mod_constexpr(long long x, long long n, int m) {",
            "    if (m == 1) return 0;",
            "    unsigned int _m = (unsigned int)(m);",
            "    unsigned long long r = 1;",
            "    unsigned long long y = safe_mod(x, m);",
            "    while (n) {",
            "        if (n & 1) r = (r * y) % _m;",
            "        y = (y * y) % _m;",
            "        n >>= 1;",
            "    }",
            "    return r;",
            "}",
            "",
            "// Reference:",
            "// M. Forisek and J. Jancina,",
            "// Fast Primality Testing for Integers That Fit into a Machine Word",
            "// @param n `0 <= n`",
            "constexpr bool is_prime_constexpr(int n) {",
            "    if (n <= 1) return false;",
            "    if (n == 2 || n == 7 || n == 61) return true;",
            "    if (n % 2 == 0) return false;",
            "    long long d = n - 1;",
            "    while (d % 2 == 0) d /= 2;",
            "    constexpr long long bases[3] = {2, 7, 61};",
            "    for (long long a : bases) {",
            "        long long t = d;",
            "        long long y = pow_mod_constexpr(a, t, n);",
            "        while (t != n - 1 && y != 1 && y != n - 1) {",
            "            y = y * y % n;",
            "            t <<= 1;",
            "        }",
            "        if (y != n - 1 && t % 2 == 0) {",
            "            return false;",
            "        }",
            "    }",
            "    return true;",
            "}",
            "template <int n> constexpr bool is_prime = is_prime_constexpr(n);",
            "",
            "// @param b `1 <= b`",
            "// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g",
            "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "    a = safe_mod(a, b);",
            "    if (a == 0) return {b, 0};",
            "",
            "    // Contracts:",
            "    // [1] s - m0 * a = 0 (mod b)",
            "    // [2] t - m1 * a = 0 (mod b)",
            "    // [3] s * |m1| + t * |m0| <= b",
            "    long long s = b, t = a;",
            "    long long m0 = 0, m1 = 1;",
            "",
            "    while (t) {",
            "        long long u = s / t;",
            "        s -= t * u;",
            "        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b",
            "",
            "        // [3]:",
            "        // (s - t * u) * |m1| + t * |m0 - m1 * u|",
            "        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)",
            "        // = s * |m1| + t * |m0| <= b",
            "",
            "        auto tmp = s;",
            "        s = t;",
            "        t = tmp;",
            "        tmp = m0;",
            "        m0 = m1;",
            "        m1 = tmp;",
            "    }",
            "    // by [3]: |m0| <= b/g",
            "    // by g != b: |m0| < b/g",
            "    if (m0 < 0) m0 += b / s;",
            "    return {s, m0};",
            "}",
            "",
            "// Compile time primitive root",
            "// @param m must be prime",
            "// @return primitive root (and minimum in now)",
            "constexpr int primitive_root_constexpr(int m) {",
            "    if (m == 2) return 1;",
            "    if (m == 167772161) return 3;",
            "    if (m == 469762049) return 3;",
            "    if (m == 754974721) return 11;",
            "    if (m == 998244353) return 3;",
            "    int divs[20] = {};",
            "    divs[0] = 2;",
            "    int cnt = 1;",
            "    int x = (m - 1) / 2;",
            "    while (x % 2 == 0) x /= 2;",
            "    for (int i = 3; (long long)(i)*i <= x; i += 2) {",
            "        if (x % i == 0) {",
            "            divs[cnt++] = i;",
            "            while (x % i == 0) {",
            "                x /= i;",
            "            }",
            "        }",
            "    }",
            "    if (x > 1) {",
            "        divs[cnt++] = x;",
            "    }",
            "    for (int g = 2;; g++) {",
            "        bool ok = true;",
            "        for (int i = 0; i < cnt; i++) {",
            "            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {",
            "                ok = false;",
            "                break;",
            "            }",
            "        }",
            "        if (ok) return g;",
            "    }",
            "}",
            "template <int m> constexpr int primitive_root = primitive_root_constexpr(m);",
            "",
            "}  // namespace internal",
            "",
            "}  // namespace atcoder",
            "",
            "#endif  // ATCODER_INTERNAL_MATH_HPP",
            "",
            "#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP",
            "#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1",
            "",
            "#include <cassert>",
            "#include <numeric>",
            "#include <type_traits>",
            "",
            "namespace atcoder {",
            "",
            "namespace internal {",
            "",
            "#ifndef _MSC_VER",
            "template <class T>",
            "using is_signed_int128 =",
            "    typename std::conditional<std::is_same<T, __int128_t>::value ||",
            "                                  std::is_same<T, __int128>::value,",
            "                              std::true_type,",
            "                              std::false_type>::type;",
            "",
            "template <class T>",
            "using is_unsigned_int128 =",
            "    typename std::conditional<std::is_same<T, __uint128_t>::value ||",
            "                                  std::is_same<T, unsigned __int128>::value,",
            "                              std::true_type,",
            "                              std::false_type>::type;",
            "",
            "template <class T>",
            "using make_unsigned_int128 =",
            "    typename std::conditional<std::is_same<T, __int128_t>::value,",
            "                              __uint128_t,",
            "                              unsigned __int128>;",
            "",
            "template <class T>",
            "using is_integral = typename std::conditional<std::is_integral<T>::value ||",
            "                                                  is_signed_int128<T>::value ||",
            "                                                  is_unsigned_int128<T>::value,",
            "                                              std::true_type,",
            "                                              std::false_type>::type;",
            "",
            "template <class T>",
            "using is_signed_int = typename std::conditional<(is_integral<T>::value &&",
            "                                                 std::is_signed<T>::value) ||",
            "                                                    is_signed_int128<T>::value,",
            "                                                std::true_type,",
            "                                                std::false_type>::type;",
            "",
            "template <class T>",
            "using is_unsigned_int =",
            "    typename std::conditional<(is_integral<T>::value &&",
            "                               std::is_unsigned<T>::value) ||",
            "                                  is_unsigned_int128<T>::value,",
            "                              std::true_type,",
            "                              std::false_type>::type;",
            "",
            "template <class T>",
            "using to_unsigned = typename std::conditional<",
            "    is_signed_int128<T>::value,",
            "    make_unsigned_int128<T>,",
            "    typename std::conditional<std::is_signed<T>::value,",
            "                              std::make_unsigned<T>,",
            "                              std::common_type<T>>::type>::type;",
            "",
            "#else",
            "",
            "template <class T> using is_integral = typename std::is_integral<T>;",
            "",
            "template <class T>",
            "using is_signed_int =",
            "    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,",
            "                              std::true_type,",
            "                              std::false_type>::type;",
            "",
            "template <class T>",
            "using is_unsigned_int =",
            "    typename std::conditional<is_integral<T>::value &&",
            "                                  std::is_unsigned<T>::value,",
            "                              std::true_type,",
            "                              std::false_type>::type;",
            "",
            "template <class T>",
            "using to_unsigned = typename std::conditional<is_signed_int<T>::value,",
            "                                              std::make_unsigned<T>,",
            "                                              std::common_type<T>>::type;",
            "",
            "#endif",
            "",
            "template <class T>",
            "using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "template <class T>",
            "using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "template <class T> using to_unsigned_t = typename to_unsigned<T>::type;",
            "",
            "}  // namespace internal",
            "",
            "}  // namespace atcoder",
            "",
            "#endif  // ATCODER_INTERNAL_TYPE_TRAITS_HPP",
            "",
            "#include <cassert>",
            "#include <numeric>",
            "#include <type_traits>",
            "",
            "#ifdef _MSC_VER",
            "#include <intrin.h>",
            "#endif",
            "",
            "namespace atcoder {",
            "",
            "namespace internal {",
            "",
            "struct modint_base {};",
            "struct static_modint_base : modint_base {};",
            "",
            "template <class T> using is_modint = std::is_base_of<modint_base, T>;",
            "template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "",
            "}  // namespace internal",
            "",
            "template <int m, std::enable_if_t<(1 <= m)>* = nullptr>",
            "struct static_modint : internal::static_modint_base {",
            "    using mint = static_modint;",
            "",
            "  public:",
            "    static constexpr int mod() { return m; }",
            "    static mint raw(int v) {",
            "        mint x;",
            "        x._v = v;",
            "        return x;",
            "    }",
            "",
            "    static_modint() : _v(0) {}",
            "    template <class T, internal::is_signed_int_t<T>* = nullptr>",
            "    static_modint(T v) {",
            "        long long x = (long long)(v % (long long)(umod()));",
            "        if (x < 0) x += umod();",
            "        _v = (unsigned int)(x);",
            "    }",
            "    template <class T, internal::is_unsigned_int_t<T>* = nullptr>",
            "    static_modint(T v) {",
            "        _v = (unsigned int)(v % umod());",
            "    }",
            "    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }",
            "",
            "    unsigned int val() const { return _v; }",
            "",
            "    mint& operator++() {",
            "        _v++;",
            "        if (_v == umod()) _v = 0;",
            "        return *this;",
            "    }",
            "    mint& operator--() {",
            "        if (_v == 0) _v = umod();",
            "        _v--;",
            "        return *this;",
            "    }",
            "    mint operator++(int) {",
            "        mint result = *this;",
            "        ++*this;",
            "        return result;",
            "    }",
            "    mint operator--(int) {",
            "        mint result = *this;",
            "        --*this;",
            "        return result;",
            "    }",
            "",
            "    mint& operator+=(const mint& rhs) {",
            "        _v += rhs._v;",
            "        if (_v >= umod()) _v -= umod();",
            "        return *this;",
            "    }",
            "    mint& operator-=(const mint& rhs) {",
            "        _v -= rhs._v;",
            "        if (_v >= umod()) _v += umod();",
            "        return *this;",
            "    }",
            "    mint& operator*=(const mint& rhs) {",
            "        unsigned long long z = _v;",
            "        z *= rhs._v;",
            "        _v = (unsigned int)(z % umod());",
            "        return *this;",
            "    }",
            "    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }",
            "",
            "    mint operator+() const { return *this; }",
            "    mint operator-() const { return mint() - *this; }",
            "",
            "    mint pow(long long n) const {",
            "        assert(0 <= n);",
            "        mint x = *this, r = 1;",
            "        while (n) {",
            "            if (n & 1) r *= x;",
            "            x *= x;",
            "            n >>= 1;",
            "        }",
            "        return r;",
            "    }",
            "    mint inv() const {",
            "        if (prime) {",
            "            assert(_v);",
            "            return pow(umod() - 2);",
            "        } else {",
            "            auto eg = internal::inv_gcd(_v, m);",
            "            assert(eg.first == 1);",
            "            return eg.second;",
            "        }",
            "    }",
            "",
            "    friend mint operator+(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) += rhs;",
            "    }",
            "    friend mint operator-(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) -= rhs;",
            "    }",
            "    friend mint operator*(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) *= rhs;",
            "    }",
            "    friend mint operator/(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) /= rhs;",
            "    }",
            "    friend bool operator==(const mint& lhs, const mint& rhs) {",
            "        return lhs._v == rhs._v;",
            "    }",
            "    friend bool operator!=(const mint& lhs, const mint& rhs) {",
            "        return lhs._v != rhs._v;",
            "    }",
            "",
            "  private:",
            "    unsigned int _v;",
            "    static constexpr unsigned int umod() { return m; }",
            "    static constexpr bool prime = internal::is_prime<m>;",
            "};",
            "",
            "template <int id> struct dynamic_modint : internal::modint_base {",
            "    using mint = dynamic_modint;",
            "",
            "  public:",
            "    static int mod() { return (int)(bt.umod()); }",
            "    static void set_mod(int m) {",
            "        assert(1 <= m);",
            "        bt = internal::barrett(m);",
            "    }",
            "    static mint raw(int v) {",
            "        mint x;",
            "        x._v = v;",
            "        return x;",
            "    }",
            "",
            "    dynamic_modint() : _v(0) {}",
            "    template <class T, internal::is_signed_int_t<T>* = nullptr>",
            "    dynamic_modint(T v) {",
            "        long long x = (long long)(v % (long long)(mod()));",
            "        if (x < 0) x += mod();",
            "        _v = (unsigned int)(x);",
            "    }",
            "    template <class T, internal::is_unsigned_int_t<T>* = nullptr>",
            "    dynamic_modint(T v) {",
            "        _v = (unsigned int)(v % mod());",
            "    }",
            "    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }",
            "",
            "    unsigned int val() const { return _v; }",
            "",
            "    mint& operator++() {",
            "        _v++;",
            "        if (_v == umod()) _v = 0;",
            "        return *this;",
            "    }",
            "    mint& operator--() {",
            "        if (_v == 0) _v = umod();",
            "        _v--;",
            "        return *this;",
            "    }",
            "    mint operator++(int) {",
            "        mint result = *this;",
            "        ++*this;",
            "        return result;",
            "    }",
            "    mint operator--(int) {",
            "        mint result = *this;",
            "        --*this;",
            "        return result;",
            "    }",
            "",
            "    mint& operator+=(const mint& rhs) {",
            "        _v += rhs._v;",
            "        if (_v >= umod()) _v -= umod();",
            "        return *this;",
            "    }",
            "    mint& operator-=(const mint& rhs) {",
            "        _v += mod() - rhs._v;",
            "        if (_v >= umod()) _v -= umod();",
            "        return *this;",
            "    }",
            "    mint& operator*=(const mint& rhs) {",
            "        _v = bt.mul(_v, rhs._v);",
            "        return *this;",
            "    }",
            "    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }",
            "",
            "    mint operator+() const { return *this; }",
            "    mint operator-() const { return mint() - *this; }",
            "",
            "    mint pow(long long n) const {",
            "        assert(0 <= n);",
            "        mint x = *this, r = 1;",
            "        while (n) {",
            "            if (n & 1) r *= x;",
            "            x *= x;",
            "            n >>= 1;",
            "        }",
            "        return r;",
            "    }",
            "    mint inv() const {",
            "        auto eg = internal::inv_gcd(_v, mod());",
            "        assert(eg.first == 1);",
            "        return eg.second;",
            "    }",
            "",
            "    friend mint operator+(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) += rhs;",
            "    }",
            "    friend mint operator-(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) -= rhs;",
            "    }",
            "    friend mint operator*(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) *= rhs;",
            "    }",
            "    friend mint operator/(const mint& lhs, const mint& rhs) {",
            "        return mint(lhs) /= rhs;",
            "    }",
            "    friend bool operator==(const mint& lhs, const mint& rhs) {",
            "        return lhs._v == rhs._v;",
            "    }",
            "    friend bool operator!=(const mint& lhs, const mint& rhs) {",
            "        return lhs._v != rhs._v;",
            "    }",
            "",
            "  private:",
            "    unsigned int _v;",
            "    static internal::barrett bt;",
            "    static unsigned int umod() { return bt.umod(); }",
            "};",
            "template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;",
            "",
            "using modint998244353 = static_modint<998244353>;",
            "using modint1000000007 = static_modint<1000000007>;",
            "using modint = dynamic_modint<-1>;",
            "",
            "namespace internal {",
            "",
            "template <class T>",
            "using is_static_modint = std::is_base_of<internal::static_modint_base, T>;",
            "",
            "template <class T>",
            "using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;",
            "",
            "template <class> struct is_dynamic_modint : public std::false_type {};",
            "template <int id>",
            "struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};",
            "",
            "template <class T>",
            "using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;",
            "",
            "}  // namespace internal",
            "",
            "}  // namespace atcoder",
            "",
            "#endif  // ATCODER_MODINT_HPP",
            "",
            "",
            "using namespace atcoder;",
            "using mint = modint;",
            ""
        ],
        "description": "Modular Arithmetic"
    },
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }                     
}